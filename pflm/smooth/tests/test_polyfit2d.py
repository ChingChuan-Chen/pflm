"""
Test suite for Polyfit2DModel class.

This module contains comprehensive tests for the 2D polynomial fitting model
with kernel smoothing, including happy path tests, edge cases, and error conditions.
"""

from typing import Tuple

import numpy as np
import pytest
from numpy.testing import assert_allclose

from pflm.smooth.kernel import KernelType
from pflm.smooth.polyfit_model import Polyfit2DModel


@pytest.mark.parametrize("dtype", [np.float32, np.float64])
def test_polyfit2d(dtype):
    bw1 = 0.15
    bw2 = 0.15
    x = np.linspace(0.0, 1.0, 11, dtype=dtype)
    x1v, x2v = np.meshgrid(x, x)
    x_grid = np.hstack((x2v.ravel(), x1v.ravel())).reshape(2, -1).T
    y = x_grid[:, 0] ** 2 + x_grid[:, 1] ** 2 + 6.0 * x_grid[:, 0] + 6.0 * x_grid[:, 1] + 2.0
    w = np.ones_like(y, dtype=dtype)

    x_new1 = np.linspace(0.0, 1.0, 11, dtype=dtype)
    x_new2 = np.linspace(0.0, 1.0, 11, dtype=dtype)

    # fmt: off
    expected_results = {
        KernelType.GAUSSIAN: np.array(
            [
                [1.98496411535527, 2.61137618850057, 3.24991383719667, 3.90356223760462, 4.57470940409128, 5.26491695522127, 5.97470940409128, 6.70356223760462, 7.44991383719667, 8.21137618850057, 8.98496411535525], #  noqa: E501
                [2.61137618850057, 3.23778826164587, 3.87632591034198, 4.52997431074992, 5.20112147723659, 5.89132902836657, 6.60112147723659, 7.32997431074993, 8.07632591034198, 8.83778826164587, 9.61137618850056], #  noqa: E501
                [3.24991383719667, 3.87632591034198, 4.51486355903809, 5.16851195944603, 5.8396591259327, 6.52986667706269, 7.2396591259327, 7.96851195944604, 8.71486355903809, 9.47632591034198, 10.2499138371967], #  noqa: E501
                [3.90356223760462, 4.52997431074993, 5.16851195944603, 5.82216035985398, 6.49330752634064, 7.18351507747063, 7.89330752634065, 8.62216035985398, 9.36851195944604, 10.1299743107499, 10.9035622376046], #  noqa: E501
                [4.57470940409128, 5.20112147723659, 5.8396591259327, 6.49330752634064, 7.1644546928273, 7.85466224395729, 8.56445469282731, 9.29330752634064, 10.0396591259327, 10.8011214772366, 11.5747094040913], #  noqa: E501
                [5.26491695522127, 5.89132902836657, 6.52986667706268, 7.18351507747063, 7.85466224395729, 8.54486979508727, 9.25466224395729, 9.98351507747063, 10.7298666770627, 11.4913290283666, 12.2649169552213], #  noqa: E501
                [5.97470940409128, 6.60112147723659, 7.2396591259327, 7.89330752634064, 8.5644546928273, 9.25466224395729, 9.96445469282731, 10.6933075263406, 11.4396591259327, 12.2011214772366, 12.9747094040913], #  noqa: E501
                [6.70356223760462, 7.32997431074993, 7.96851195944603, 8.62216035985398, 9.29330752634064, 9.98351507747063, 10.6933075263406, 11.422160359854, 12.168511959446, 12.9299743107499, 13.7035622376046], #  noqa: E501
                [7.44991383719668, 8.07632591034198, 8.71486355903808, 9.36851195944603, 10.0396591259327, 10.7298666770627, 11.4396591259327, 12.168511959446, 12.9148635590381, 13.676325910342, 14.4499138371967], #  noqa: E501
                [8.21137618850057, 8.83778826164588, 9.47632591034198, 10.1299743107499, 10.8011214772366, 11.4913290283666, 12.2011214772366, 12.9299743107499, 13.676325910342, 14.4377882616459, 15.2113761885006], #  noqa: E501
                [8.98496411535527, 9.61137618850058, 10.2499138371967, 10.9035622376046, 11.5747094040913, 12.2649169552213, 12.9747094040913, 13.7035622376046, 14.4499138371967, 15.2113761885006, 15.9849641153553], #  noqa: E501
            ]
        ),
        KernelType.LOGISTIC: np.array(
            [
                [1.92138403575896, 2.56976002587655, 3.22502796596351, 3.89060105884695, 4.56898605484621, 5.26162658917806, 5.9689860548462, 6.69060105884694, 7.4250279659635, 8.16976002587656, 8.92138403575897], #  noqa: E501
                [2.56976002587655, 3.21813601599413, 3.87340395608109, 4.53897704896453, 5.21736204496379, 5.91000257929565, 6.61736204496379, 7.33897704896453, 8.07340395608108, 8.81813601599412, 9.56976002587656], #  noqa: E501
                [3.22502796596351, 3.87340395608109, 4.52867189616805, 5.1942449890515, 5.87262998505076, 6.56527051938261, 7.27262998505076, 7.9942449890515, 8.72867189616805, 9.47340395608109, 10.2250279659635], #  noqa: E501
                [3.89060105884696, 4.53897704896454, 5.1942449890515, 5.85981808193495, 6.53820307793421, 7.23084361226606, 7.9382030779342, 8.65981808193495, 9.3942449890515, 10.1389770489645, 10.8906010588469], #  noqa: E501
                [4.56898605484622, 5.2173620449638, 5.87262998505076, 6.53820307793421, 7.21658807393347, 7.90922860826532, 8.61658807393347, 9.33820307793421, 10.0726299850508, 10.8173620449638, 11.5689860548462], #  noqa: E501
                [5.26162658917807, 5.91000257929565, 6.56527051938261, 7.23084361226606, 7.90922860826532, 8.60186914259717, 9.30922860826532, 10.0308436122661, 10.7652705193826, 11.5100025792957, 12.2616265891781], #  noqa: E501
                [5.96898605484622, 6.6173620449638, 7.27262998505076, 7.93820307793421, 8.61658807393347, 9.30922860826532, 10.0165880739335, 10.7382030779342, 11.4726299850508, 12.2173620449638, 12.9689860548462], #  noqa: E501
                [6.69060105884696, 7.33897704896454, 7.9942449890515, 8.65981808193495, 9.33820307793421, 10.0308436122661, 10.7382030779342, 11.459818081935, 12.1942449890515, 12.9389770489645, 13.690601058847], #  noqa: E501
                [7.42502796596351, 8.07340395608109, 8.72867189616806, 9.3942449890515, 10.0726299850508, 10.7652705193826, 11.4726299850508, 12.1942449890515, 12.9286718961681, 13.6734039560811, 14.4250279659635], #  noqa: E501
                [8.16976002587655, 8.81813601599413, 9.47340395608109, 10.1389770489645, 10.8173620449638, 11.5100025792957, 12.2173620449638, 12.9389770489645, 13.6734039560811, 14.4181360159941, 15.1697600258766], #  noqa: E501
                [8.92138403575898, 9.56976002587655, 10.2250279659635, 10.890601058847, 11.5689860548462, 12.2616265891781, 12.9689860548462, 13.690601058847, 14.4250279659635, 15.1697600258766, 15.921384035759], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.SIGMOID: np.array(
            [
                [1.9405441902563, 2.58322950460427, 3.23221789493025, 3.89307865135335, 4.56872414141014, 5.26047868337069, 5.96872414141014, 6.69307865135335, 7.43221789493024, 8.18322950460426, 8.94054419025629], #  noqa: E501
                [2.58322950460427, 3.22591481895223, 3.87490320927821, 4.53576396570131, 5.2114094557581, 5.90316399771866, 6.6114094557581, 7.33576396570132, 8.07490320927821, 8.82591481895224, 9.58322950460426], #  noqa: E501
                [3.23221789493025, 3.87490320927821, 4.52389159960419, 5.18475235602729, 5.86039784608408, 6.55215238804464, 7.26039784608408, 7.98475235602729, 8.72389159960419, 9.47490320927821, 10.2322178949303], #  noqa: E501
                [3.89307865135335, 4.53576396570131, 5.18475235602729, 5.84561311245039, 6.52125860250719, 7.21301314446774, 7.92125860250718, 8.64561311245039, 9.38475235602729, 10.1357639657013, 10.8930786513534], #  noqa: E501
                [4.56872414141014, 5.2114094557581, 5.86039784608408, 6.52125860250718, 7.19690409256398, 7.88865863452453, 8.59690409256398, 9.32125860250718, 10.0603978460841, 10.8114094557581, 11.5687241414101], #  noqa: E501
                [5.26047868337069, 5.90316399771866, 6.55215238804463, 7.21301314446774, 7.88865863452454, 8.58041317648509, 9.28865863452453, 10.0130131444677, 10.7521523880446, 11.5031639977187, 12.2604786833707], #  noqa: E501
                [5.96872414141014, 6.6114094557581, 7.26039784608408, 7.92125860250718, 8.59690409256398, 9.28865863452453, 9.99690409256397, 10.7212586025072, 11.4603978460841, 12.2114094557581, 12.9687241414101], #  noqa: E501
                [6.69307865135335, 7.33576396570131, 7.98475235602729, 8.64561311245039, 9.32125860250719, 10.0130131444677, 10.7212586025072, 11.4456131124504, 12.1847523560273, 12.9357639657013, 13.6930786513533], #  noqa: E501
                [7.43221789493025, 8.0749032092782, 8.72389159960419, 9.38475235602729, 10.0603978460841, 10.7521523880446, 11.4603978460841, 12.1847523560273, 12.9238915996042, 13.6749032092782, 14.4322178949302], #  noqa: E501
                [8.18322950460427, 8.82591481895223, 9.47490320927821, 10.1357639657013, 10.8114094557581, 11.5031639977187, 12.2114094557581, 12.9357639657013, 13.6749032092782, 14.4259148189522, 15.1832295046043], #  noqa: E501
                [8.9405441902563, 9.58322950460427, 10.2322178949302, 10.8930786513533, 11.5687241414101, 12.2604786833707, 12.9687241414101, 13.6930786513533, 14.4322178949303, 15.1832295046043, 15.9405441902563], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.RECTANGULAR: np.array(
            [
                [2, 2.61666666666667, 3.24666666666667, 3.89666666666667, 4.56666666666667, 5.25666666666667, 5.96666666666667, 6.69666666666667, 7.44666666666667, 8.21666666666667, 9], #  noqa: E501
                [2.61666666666667, 3.23333333333333, 3.86333333333333, 4.51333333333333, 5.18333333333333, 5.87333333333333, 6.58333333333333, 7.31333333333333, 8.06333333333333, 8.83333333333333, 9.61666666666667], #  noqa: E501
                [3.24666666666667, 3.86333333333333, 4.49333333333333, 5.14333333333333, 5.81333333333333, 6.50333333333333, 7.21333333333333, 7.94333333333333, 8.69333333333334, 9.46333333333333, 10.2466666666667], #  noqa: E501
                [3.89666666666667, 4.51333333333333, 5.14333333333333, 5.79333333333333, 6.46333333333333, 7.15333333333333, 7.86333333333333, 8.59333333333333, 9.34333333333333, 10.1133333333333, 10.8966666666667], #  noqa: E501
                [4.56666666666667, 5.18333333333333, 5.81333333333333, 6.46333333333333, 7.13333333333333, 7.82333333333333, 8.53333333333333, 9.26333333333333, 10.0133333333333, 10.7833333333333, 11.5666666666667], #  noqa: E501
                [5.25666666666667, 5.87333333333333, 6.50333333333333, 7.15333333333333, 7.82333333333333, 8.51333333333334, 9.22333333333334, 9.95333333333333, 10.7033333333333, 11.4733333333333, 12.2566666666667], #  noqa: E501
                [5.96666666666667, 6.58333333333333, 7.21333333333333, 7.86333333333333, 8.53333333333333, 9.22333333333334, 9.93333333333333, 10.6633333333333, 11.4133333333333, 12.1833333333333, 12.9666666666667], #  noqa: E501
                [6.69666666666667, 7.31333333333333, 7.94333333333333, 8.59333333333333, 9.26333333333333, 9.95333333333333, 10.6633333333333, 11.3933333333333, 12.1433333333333, 12.9133333333333, 13.6966666666667], #  noqa: E501
                [7.44666666666667, 8.06333333333333, 8.69333333333334, 9.34333333333333, 10.0133333333333, 10.7033333333333, 11.4133333333333, 12.1433333333333, 12.8933333333333, 13.6633333333333, 14.4466666666667], #  noqa: E501
                [8.21666666666667, 8.83333333333333, 9.46333333333333, 10.1133333333333, 10.7833333333333, 11.4733333333333, 12.1833333333333, 12.9133333333333, 13.6633333333333, 14.4333333333333, 15.2166666666667], #  noqa: E501
                [9, 9.61666666666667, 10.2466666666667, 10.8966666666667, 11.5666666666667, 12.2566666666667, 12.9666666666667, 13.6966666666667, 14.4466666666667, 15.2166666666667, 16], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.TRIANGULAR: np.array(
            [
                [2, 2.614, 3.244, 3.894, 4.564, 5.254, 5.964, 6.694, 7.444, 8.214, 9],
                [2.614, 3.228, 3.858, 4.508, 5.178, 5.868, 6.578, 7.308, 8.058, 8.828, 9.614],
                [3.244, 3.858, 4.488, 5.138, 5.808, 6.498, 7.208, 7.938, 8.688, 9.458, 10.244],
                [3.894, 4.508, 5.138, 5.788, 6.458, 7.148, 7.858, 8.588, 9.338, 10.108, 10.894],
                [4.564, 5.178, 5.808, 6.458, 7.128, 7.818, 8.528, 9.258, 10.008, 10.778, 11.564],
                [5.254, 5.868, 6.498, 7.148, 7.818, 8.508, 9.218, 9.948, 10.698, 11.468, 12.254],
                [5.964, 6.578, 7.208, 7.858, 8.528, 9.218, 9.928, 10.658, 11.408, 12.178, 12.964],
                [6.694, 7.308, 7.938, 8.588, 9.258, 9.948, 10.658, 11.388, 12.138, 12.908, 13.694],
                [7.444, 8.058, 8.688, 9.338, 10.008, 10.698, 11.408, 12.138, 12.888, 13.658, 14.444],
                [8.214, 8.828, 9.458, 10.108, 10.778, 11.468, 12.178, 12.908, 13.658, 14.428, 15.214],
                [9, 9.614, 10.244, 10.894, 11.564, 12.254, 12.964, 13.694, 14.444, 15.214, 16],
            ],
            dtype=dtype
        ),
        KernelType.EPANECHNIKOV: np.array(
            [
                [2, 2.61526315789474, 3.24526315789474, 3.89526315789474, 4.56526315789474, 5.25526315789474, 5.96526315789474, 6.69526315789474, 7.44526315789474, 8.21526315789474, 9], #  noqa: E501
                [2.61526315789474, 3.23052631578947, 3.86052631578947, 4.51052631578948, 5.18052631578947, 5.87052631578947, 6.58052631578947, 7.31052631578947, 8.06052631578947, 8.83052631578948, 9.61526315789474], #  noqa: E501
                [3.24526315789474, 3.86052631578947, 4.49052631578947, 5.14052631578947, 5.81052631578947, 6.50052631578948, 7.21052631578947, 7.94052631578948, 8.69052631578947, 9.46052631578948, 10.2452631578947], #  noqa: E501
                [3.89526315789474, 4.51052631578948, 5.14052631578947, 5.79052631578948, 6.46052631578948, 7.15052631578947, 7.86052631578948, 8.59052631578948, 9.34052631578948, 10.1105263157895, 10.8952631578947], #  noqa: E501
                [4.56526315789474, 5.18052631578947, 5.81052631578947, 6.46052631578948, 7.13052631578947, 7.82052631578948, 8.53052631578948, 9.26052631578947, 10.0105263157895, 10.7805263157895, 11.5652631578947], #  noqa: E501
                [5.25526315789474, 5.87052631578947, 6.50052631578947, 7.15052631578947, 7.82052631578947, 8.51052631578948, 9.22052631578948, 9.95052631578948, 10.7005263157895, 11.4705263157895, 12.2552631578947], #  noqa: E501
                [5.96526315789474, 6.58052631578947, 7.21052631578948, 7.86052631578947, 8.53052631578948, 9.22052631578948, 9.93052631578948, 10.6605263157895, 11.4105263157895, 12.1805263157895, 12.9652631578947], #  noqa: E501
                [6.69526315789474, 7.31052631578947, 7.94052631578947, 8.59052631578948, 9.26052631578947, 9.95052631578948, 10.6605263157895, 11.3905263157895, 12.1405263157895, 12.9105263157895, 13.6952631578947], #  noqa: E501
                [7.44526315789474, 8.06052631578947, 8.69052631578947, 9.34052631578948, 10.0105263157895, 10.7005263157895, 11.4105263157895, 12.1405263157895, 12.8905263157895, 13.6605263157895, 14.4452631578947], #  noqa: E501
                [8.21526315789474, 8.83052631578948, 9.46052631578947, 10.1105263157895, 10.7805263157895, 11.4705263157895, 12.1805263157895, 12.9105263157895, 13.6605263157895, 14.4305263157895, 15.2152631578947], #  noqa: E501
                [9, 9.61526315789474, 10.2452631578947, 10.8952631578947, 11.5652631578947, 12.2552631578947, 12.9652631578947, 13.6952631578947, 14.4452631578947, 15.2152631578947, 16], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.BIWEIGHT: np.array(
            [
                [2, 2.61381679389313, 3.24381679389313, 3.89381679389313, 4.56381679389313, 5.25381679389313, 5.96381679389313, 6.69381679389313, 7.44381679389313, 8.21381679389313, 9], #  noqa: E501
                [2.61381679389313, 3.22763358778626, 3.85763358778626, 4.50763358778626, 5.17763358778626, 5.86763358778626, 6.57763358778626, 7.30763358778626, 8.05763358778626, 8.82763358778626, 9.61381679389313], #  noqa: E501
                [3.24381679389313, 3.85763358778626, 4.48763358778626, 5.13763358778626, 5.80763358778626, 6.49763358778626, 7.20763358778626, 7.93763358778626, 8.68763358778626, 9.45763358778626, 10.2438167938931], #  noqa: E501
                [3.89381679389313, 4.50763358778626, 5.13763358778626, 5.78763358778626, 6.45763358778626, 7.14763358778626, 7.85763358778626, 8.58763358778626, 9.33763358778626, 10.1076335877863, 10.8938167938931], #  noqa: E501
                [4.56381679389313, 5.17763358778626, 5.80763358778626, 6.45763358778626, 7.12763358778626, 7.81763358778626, 8.52763358778626, 9.25763358778626, 10.0076335877863, 10.7776335877863, 11.5638167938931], #  noqa: E501
                [5.25381679389313, 5.86763358778626, 6.49763358778626, 7.14763358778626, 7.81763358778626, 8.50763358778626, 9.21763358778626, 9.94763358778626, 10.6976335877863, 11.4676335877863, 12.2538167938931], #  noqa: E501
                [5.96381679389313, 6.57763358778626, 7.20763358778626, 7.85763358778626, 8.52763358778626, 9.21763358778626, 9.92763358778626, 10.6576335877863, 11.4076335877863, 12.1776335877863, 12.9638167938931], #  noqa: E501
                [6.69381679389313, 7.30763358778626, 7.93763358778626, 8.58763358778626, 9.25763358778626, 9.94763358778626, 10.6576335877863, 11.3876335877863, 12.1376335877863, 12.9076335877863, 13.6938167938931], #  noqa: E501
                [7.44381679389313, 8.05763358778626, 8.68763358778626, 9.33763358778626, 10.0076335877863, 10.6976335877863, 11.4076335877863, 12.1376335877863, 12.8876335877863, 13.6576335877863, 14.4438167938931], #  noqa: E501
                [8.21381679389313, 8.82763358778626, 9.45763358778626, 10.1076335877863, 10.7776335877863, 11.4676335877863, 12.1776335877863, 12.9076335877863, 13.6576335877863, 14.4276335877863, 15.2138167938931], #  noqa: E501
                [9, 9.61381679389313, 10.2438167938931, 10.8938167938931, 11.5638167938931, 12.2538167938931, 12.9638167938931, 13.6938167938931, 14.4438167938931, 15.2138167938931, 16], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.TRIWEIGHT: np.array(
            [
                [2, 2.61255362614913, 3.24255362614913, 3.89255362614913, 4.56255362614913, 5.25255362614913, 5.96255362614913, 6.69255362614913, 7.44255362614913, 8.21255362614913, 9], #  noqa: E501
                [2.61255362614913, 3.22510725229826, 3.85510725229826, 4.50510725229826, 5.17510725229826, 5.86510725229826, 6.57510725229826, 7.30510725229826, 8.05510725229826, 8.82510725229826, 9.61255362614913], #  noqa: E501
                [3.24255362614913, 3.85510725229826, 4.48510725229826, 5.13510725229826, 5.80510725229826, 6.49510725229826, 7.20510725229826, 7.93510725229826, 8.68510725229826, 9.45510725229826, 10.2425536261491], #  noqa: E501
                [3.89255362614913, 4.50510725229826, 5.13510725229826, 5.78510725229826, 6.45510725229826, 7.14510725229826, 7.85510725229826, 8.58510725229826, 9.33510725229826, 10.1051072522983, 10.8925536261491], #  noqa: E501
                [4.56255362614913, 5.17510725229826, 5.80510725229826, 6.45510725229826, 7.12510725229826, 7.81510725229826, 8.52510725229826, 9.25510725229826, 10.0051072522983, 10.7751072522983, 11.5625536261491], #  noqa: E501
                [5.25255362614913, 5.86510725229826, 6.49510725229826, 7.14510725229826, 7.81510725229826, 8.50510725229826, 9.21510725229827, 9.94510725229826, 10.6951072522983, 11.4651072522983, 12.2525536261491], #  noqa: E501
                [5.96255362614913, 6.57510725229826, 7.20510725229826, 7.85510725229826, 8.52510725229827, 9.21510725229826, 9.92510725229826, 10.6551072522983, 11.4051072522983, 12.1751072522983, 12.9625536261491], #  noqa: E501
                [6.69255362614913, 7.30510725229826, 7.93510725229826, 8.58510725229826, 9.25510725229826, 9.94510725229826, 10.6551072522983, 11.3851072522983, 12.1351072522983, 12.9051072522983, 13.6925536261491], #  noqa: E501
                [7.44255362614913, 8.05510725229826, 8.68510725229826, 9.33510725229826, 10.0051072522983, 10.6951072522983, 11.4051072522983, 12.1351072522983, 12.8851072522983, 13.6551072522983, 14.4425536261491], #  noqa: E501
                [8.21255362614913, 8.82510725229826, 9.45510725229826, 10.1051072522983, 10.7751072522983, 11.4651072522983, 12.1751072522983, 12.9051072522983, 13.6551072522983, 14.4251072522983, 15.2125536261491], #  noqa: E501
                [9, 9.61255362614913, 10.2425536261491, 10.8925536261491, 11.5625536261491, 12.2525536261491, 12.9625536261491, 13.6925536261491, 14.4425536261491, 15.2125536261491, 16], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.TRICUBE: np.array(
            [
                [2, 2.61410706266279, 3.2441070626628, 3.89410706266279, 4.5641070626628, 5.25410706266279, 5.9641070626628, 6.69410706266279, 7.4441070626628, 8.21410706266279, 9], #  noqa: E501
                [2.61410706266279, 3.22821412532559, 3.85821412532559, 4.50821412532559, 5.17821412532559, 5.86821412532559, 6.57821412532559, 7.30821412532559, 8.05821412532559, 8.82821412532559, 9.61410706266279], #  noqa: E501
                [3.2441070626628, 3.85821412532559, 4.48821412532559, 5.13821412532559, 5.80821412532559, 6.49821412532559, 7.20821412532559, 7.93821412532559, 8.68821412532559, 9.45821412532559, 10.2441070626628], #  noqa: E501
                [3.8941070626628, 4.50821412532559, 5.13821412532559, 5.78821412532559, 6.45821412532559, 7.14821412532559, 7.85821412532559, 8.58821412532559, 9.33821412532559, 10.1082141253256, 10.8941070626628], #  noqa: E501
                [4.5641070626628, 5.17821412532559, 5.80821412532559, 6.45821412532559, 7.12821412532559, 7.81821412532559, 8.52821412532559, 9.25821412532559, 10.0082141253256, 10.7782141253256, 11.5641070626628], #  noqa: E501
                [5.2541070626628, 5.86821412532559, 6.49821412532559, 7.14821412532559, 7.81821412532559, 8.50821412532559, 9.21821412532559, 9.94821412532559, 10.6982141253256, 11.4682141253256, 12.2541070626628], #  noqa: E501
                [5.96410706266279, 6.57821412532559, 7.20821412532559, 7.85821412532559, 8.52821412532559, 9.21821412532559, 9.92821412532559, 10.6582141253256, 11.4082141253256, 12.1782141253256, 12.9641070626628], #  noqa: E501
                [6.6941070626628, 7.30821412532559, 7.93821412532559, 8.58821412532559, 9.25821412532559, 9.94821412532559, 10.6582141253256, 11.3882141253256, 12.1382141253256, 12.9082141253256, 13.6941070626628], #  noqa: E501
                [7.4441070626628, 8.05821412532559, 8.68821412532559, 9.33821412532559, 10.0082141253256, 10.6982141253256, 11.4082141253256, 12.1382141253256, 12.8882141253256, 13.6582141253256, 14.4441070626628], #  noqa: E501
                [8.21410706266279, 8.82821412532559, 9.45821412532559, 10.1082141253256, 10.7782141253256, 11.4682141253256, 12.1782141253256, 12.9082141253256, 13.6582141253256, 14.4282141253256, 15.2141070626628], #  noqa: E501
                [9, 9.61410706266279, 10.2441070626628, 10.8941070626628, 11.5641070626628, 12.2541070626628, 12.9641070626628, 13.6941070626628, 14.4441070626628, 15.2141070626628, 16], #  noqa: E501
            ],
            dtype=dtype
        ),
        KernelType.COSINE: np.array(
            [
                [2, 2.615, 3.245, 3.895, 4.565, 5.255, 5.965, 6.695, 7.445, 8.215, 9],
                [2.615, 3.23, 3.86, 4.51, 5.18, 5.87, 6.58, 7.31, 8.06, 8.83, 9.615],
                [3.245, 3.86, 4.49, 5.14, 5.81, 6.5, 7.21, 7.94, 8.69, 9.46, 10.245],
                [3.895, 4.51, 5.14, 5.79, 6.46, 7.15, 7.86, 8.59, 9.34, 10.11, 10.895],
                [4.565, 5.18, 5.81, 6.46, 7.13, 7.82, 8.53, 9.26, 10.01, 10.78, 11.565],
                [5.255, 5.87, 6.5, 7.15, 7.82, 8.51, 9.22, 9.95, 10.7, 11.47, 12.255],
                [5.965, 6.58, 7.21, 7.86, 8.53, 9.22, 9.93, 10.66, 11.41, 12.18, 12.965],
                [6.695, 7.31, 7.94, 8.59, 9.26, 9.95, 10.66, 11.39, 12.14, 12.91, 13.695],
                [7.445, 8.06, 8.69, 9.34, 10.01, 10.7, 11.41, 12.14, 12.89, 13.66, 14.445],
                [8.215, 8.83, 9.46, 10.11, 10.78, 11.47, 12.18, 12.91, 13.66, 14.43, 15.215],
                [9.00000000000001, 9.615, 10.245, 10.895, 11.565, 12.255, 12.965, 13.695, 14.445, 15.215, 16],
            ],
            dtype=dtype
        )
    }
    # fmt: on

    for kernel_type, expected in expected_results.items():
        model = Polyfit2DModel(kernel_type=kernel_type, obs_grid1=x, obs_grid2=x)
        model.fit(x_grid, y, sample_weight=w, bandwidth1=bw1, bandwidth2=bw2)
        y_pred = model.predict(x_new1, x_new2)
        assert_allclose(y_pred, expected, rtol=1e-5, atol=1e-6, err_msg=f"Failed for kernel {kernel_type} with dtype {dtype}")


@pytest.mark.parametrize("order", ['C', 'F'])
def test_polyfit2d_different_order_array(order):
    x = np.linspace(0.0, 1.0, 11)
    x1v, x2v = np.meshgrid(x, x)
    x_grid = np.hstack((x2v.ravel(), x1v.ravel())).reshape(2, -1).T
    if order == 'C':
        x_grid = np.ascontiguousarray(x_grid)
    else:
        x_grid = np.asfortranarray(x_grid)

    y = x_grid[:, 0] ** 2 + x_grid[:, 1] ** 2 + 6.0 * x_grid[:, 0] + 6.0 * x_grid[:, 1] + 2.0
    w = np.ones(len(y), order=order, dtype=x.dtype)
    if order == 'C':
        x_new1 = np.ascontiguousarray(np.linspace(0.0, 1.0, 11, dtype=x.dtype))
        x_new2 = np.ascontiguousarray(np.linspace(0.0, 1.0, 11, dtype=x.dtype))
    else:
        x_new1 = np.asfortranarray(np.linspace(0.0, 1.0, 11, dtype=x.dtype))
        x_new2 = np.asfortranarray(np.linspace(0.0, 1.0, 11, dtype=x.dtype))

    # fmt: off
    expected_results = np.array(
        [
            [1.98496411535527, 2.61137618850057, 3.24991383719667, 3.90356223760462, 4.57470940409128, 5.26491695522127, 5.97470940409128, 6.70356223760462, 7.44991383719667, 8.21137618850057, 8.98496411535525], #  noqa: E501
            [2.61137618850057, 3.23778826164587, 3.87632591034198, 4.52997431074992, 5.20112147723659, 5.89132902836657, 6.60112147723659, 7.32997431074993, 8.07632591034198, 8.83778826164587, 9.61137618850056], #  noqa: E501
            [3.24991383719667, 3.87632591034198, 4.51486355903809, 5.16851195944603, 5.8396591259327, 6.52986667706269, 7.2396591259327, 7.96851195944604, 8.71486355903809, 9.47632591034198, 10.2499138371967], #  noqa: E501
            [3.90356223760462, 4.52997431074993, 5.16851195944603, 5.82216035985398, 6.49330752634064, 7.18351507747063, 7.89330752634065, 8.62216035985398, 9.36851195944604, 10.1299743107499, 10.9035622376046], #  noqa: E501
            [4.57470940409128, 5.20112147723659, 5.8396591259327, 6.49330752634064, 7.1644546928273, 7.85466224395729, 8.56445469282731, 9.29330752634064, 10.0396591259327, 10.8011214772366, 11.5747094040913], #  noqa: E501
            [5.26491695522127, 5.89132902836657, 6.52986667706268, 7.18351507747063, 7.85466224395729, 8.54486979508727, 9.25466224395729, 9.98351507747063, 10.7298666770627, 11.4913290283666, 12.2649169552213], #  noqa: E501
            [5.97470940409128, 6.60112147723659, 7.2396591259327, 7.89330752634064, 8.5644546928273, 9.25466224395729, 9.96445469282731, 10.6933075263406, 11.4396591259327, 12.2011214772366, 12.9747094040913], #  noqa: E501
            [6.70356223760462, 7.32997431074993, 7.96851195944603, 8.62216035985398, 9.29330752634064, 9.98351507747063, 10.6933075263406, 11.422160359854, 12.168511959446, 12.9299743107499, 13.7035622376046], #  noqa: E501
            [7.44991383719668, 8.07632591034198, 8.71486355903808, 9.36851195944603, 10.0396591259327, 10.7298666770627, 11.4396591259327, 12.168511959446, 12.9148635590381, 13.676325910342, 14.4499138371967], #  noqa: E501
            [8.21137618850057, 8.83778826164588, 9.47632591034198, 10.1299743107499, 10.8011214772366, 11.4913290283666, 12.2011214772366, 12.9299743107499, 13.676325910342, 14.4377882616459, 15.2113761885006], #  noqa: E501
            [8.98496411535527, 9.61137618850058, 10.2499138371967, 10.9035622376046, 11.5747094040913, 12.2649169552213, 12.9747094040913, 13.7035622376046, 14.4499138371967, 15.2113761885006, 15.9849641153553], #  noqa: E501
        ], order=order, dtype=x.dtype
    )
    # fmt: on

    # Test with Polyfit2DModel
    model = Polyfit2DModel(kernel_type=KernelType.GAUSSIAN, obs_grid1=x_new1, obs_grid2=x_new2, degree=1)
    model.fit(x_grid, y, sample_weight=w, bandwidth1=0.15, bandwidth2=0.15)
    y_pred = model.predict(x_new1, x_new2)

    # Basic shape and sanity checks
    assert y_pred.shape == (len(x_new1), len(x_new2))
    assert np.all(np.isfinite(y_pred)), "Prediction contains NaN or Inf values"


def make_test_inputs_2d() -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Create standard test inputs for Polyfit2DModel tests.

    Returns
    -------
    Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]
        A tuple containing:
        - X: Input features array of shape (n_samples, 2)
        - y: Target values array
        - w: Sample weights array
        - x_new1: Grid points for first dimension
        - x_new2: Grid points for second dimension
    """
    x1 = np.array([0.1, 0.2, 0.3, 0.4, 0.5])
    x2 = np.array([0.1, 0.2, 0.3, 0.4, 0.5])
    X = np.column_stack([np.repeat(x1, len(x2)), np.tile(x2, len(x1))])
    y = X[:, 0] + X[:, 1]  # Simple linear relationship
    w = np.ones(len(y))
    x_new1 = np.linspace(0.1, 0.5, 5)
    x_new2 = np.linspace(0.1, 0.5, 5)
    return X, y, w, x_new1, x_new2


def test_polyfit2d_x_not_2d() -> None:
    """Test that Polyfit2DModel raises error for non-2D X input."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    # Test with 1D input
    X_1d = np.array([0.1, 0.2, 0.3])
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="Expected 2D array, got 1D array instead"):
        model.fit(X_1d, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_x_wrong_features() -> None:
    """Test that Polyfit2DModel raises error for wrong number of features."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    # Test with 3 features
    X_3d = np.column_stack([X, np.ones(X.shape[0])])
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="X must have exactly 2 features for 2D model, got 3"):
        model.fit(X_3d, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_y_x_size_mismatch() -> None:
    """Test that Polyfit2DModel raises error when X and y have different sizes."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    y_wrong = np.array([0.1, 0.2, 0.3])  # Different size than X
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="y must have the same size as X"):
        model.fit(X, y_wrong, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_w_negative() -> None:
    """Test that Polyfit2DModel raises error for negative sample weights."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    w_negative = w.copy()
    w_negative[0] = -1.0
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="All sample weights must be non-negative"):
        model.fit(X, y, sample_weight=w_negative, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_y_w_size_mismatch() -> None:
    """Test that Polyfit2DModel raises error when y and sample_weight have different sizes."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    w_wrong = np.array([1.0, 1.0, 1.0])  # Different size than y
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="sample_weight must have the same length as y"):
        model.fit(X, y, sample_weight=w_wrong, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_bandwidth_non_positive() -> None:
    """Test that Polyfit2DModel raises error for non-positive bandwidths."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test zero bandwidth1
    with pytest.raises(ValueError, match="bandwidth1 must be positive"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.0, bandwidth2=0.1)

    # Test zero bandwidth2
    with pytest.raises(ValueError, match="bandwidth2 must be positive"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.0)

    # Test negative bandwidth1
    with pytest.raises(ValueError, match="bandwidth1 must be positive"):
        model.fit(X, y, sample_weight=w, bandwidth1=-0.1, bandwidth2=0.1)

    # Test negative bandwidth2
    with pytest.raises(ValueError, match="bandwidth2 must be positive"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=-0.1)


def test_polyfit2d_partial_bandwidth_provided() -> None:
    """Test that Polyfit2DModel raises error when only one bandwidth is provided."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()

    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test only bandwidth1 provided
    with pytest.raises(ValueError, match="If one bandwidth is provided, both must be provided"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=None)

    # Test only bandwidth2 provided
    with pytest.raises(ValueError, match="If one bandwidth is provided, both must be provided"):
        model.fit(X, y, sample_weight=w, bandwidth1=None, bandwidth2=0.1)


def test_polyfit2d_kernel_type_invalid() -> None:
    """Test that Polyfit2DModel raises error for invalid kernel type."""
    with pytest.raises(ValueError, match="kernel_type must be one of"):
        Polyfit2DModel(kernel_type="invalid")


def test_polyfit2d_degree_non_positive() -> None:
    """Test that Polyfit2DModel raises error for non-positive degree."""
    with pytest.raises(ValueError, match="Degree of polynomial, degree, should be positive"):
        Polyfit2DModel(degree=0)


def test_polyfit2d_deriv1_negative() -> None:
    """Test that Polyfit2DModel raises error for negative derivative order in first dimension."""
    with pytest.raises(ValueError, match="Order of derivative, deriv1 and deriv2, should be non-negative"):
        Polyfit2DModel(deriv1=-1)


def test_polyfit2d_deriv2_negative() -> None:
    """Test that Polyfit2DModel raises error for negative derivative order in second dimension."""
    with pytest.raises(ValueError, match="Order of derivative, deriv1 and deriv2, should be non-negative"):
        Polyfit2DModel(deriv2=-1)


def test_polyfit2d_degree_less_than_sum_deriv() -> None:
    """Test that Polyfit2DModel raises error when degree is less than sum of derivative orders."""
    with pytest.raises(ValueError, match="Degree of polynomial, degree, should be greater than or equal to sum"):
        Polyfit2DModel(degree=1, deriv1=1, deriv2=1)


@pytest.mark.parametrize("dtype", [np.float32, np.float64])
def test_polyfit2d_nan_inputs(dtype: np.dtype) -> None:
    """
    Test that Polyfit2DModel raises error for NaN inputs.

    Parameters
    ----------
    dtype : np.dtype
        The numpy data type to test (float32 or float64).
    """
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    X = X.astype(dtype)
    y = y.astype(dtype)
    w = w.astype(dtype)

    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test NaN in X
    X_nan = X.copy()
    X_nan[0, 0] = np.nan
    with pytest.raises(ValueError, match="Input contains NaN"):
        model.fit(X_nan, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)

    # Test NaN in y
    y_nan = y.copy()
    y_nan[0] = np.nan
    with pytest.raises(ValueError, match="Input contains NaN"):
        model.fit(X, y_nan, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)

    # Test NaN in sample_weight
    w_nan = w.copy()
    w_nan[0] = np.nan
    with pytest.raises(ValueError, match="Input contains NaN"):
        model.fit(X, y, sample_weight=w_nan, bandwidth1=0.1, bandwidth2=0.1)


@pytest.mark.parametrize("bad_type", [float("nan"), np.nan])
def test_polyfit2d_bandwidth_nan(bad_type) -> None:
    """
    Test that Polyfit2DModel raises error for NaN bandwidths.

    Parameters
    ----------
    bad_type : Union[float, np.floating]
        Invalid bandwidth value (NaN).
    """
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test NaN bandwidth1
    with pytest.raises(ValueError, match="bandwidth1 must not be NaN"):
        model.fit(X, y, sample_weight=w, bandwidth1=bad_type, bandwidth2=0.1)

    # Test NaN bandwidth2
    with pytest.raises(ValueError, match="bandwidth2 must not be NaN"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=bad_type)


@pytest.mark.parametrize("bad_type", ["2", [1], (2,), {"a": 1}])
def test_polyfit2d_bandwidth_non_numeric_type(bad_type) -> None:
    """
    Test that Polyfit2DModel raises error for non-numeric bandwidth types.

    Parameters
    ----------
    bad_type : Union[str, List[int], Tuple[int], dict]
        Invalid bandwidth type.
    """
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test invalid bandwidth1 type
    with pytest.raises(ValueError, match="bandwidth1 must be positive float or integer"):
        model.fit(X, y, sample_weight=w, bandwidth1=bad_type, bandwidth2=0.1)

    # Test invalid bandwidth2 type
    with pytest.raises(ValueError, match="bandwidth2 must be positive float or integer"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=bad_type)


@pytest.mark.parametrize("bad_type", [1.5, "2", float("nan"), np.nan, None, [1], (2,), {"a": 1}])
def test_polyfit2d_degree_non_int_type(bad_type) -> None:
    """
    Test that Polyfit2DModel raises error for non-integer degree types.

    Parameters
    ----------
    bad_type : Union[float, str, None, List[int], Tuple[int], dict]
        Invalid degree type.
    """
    with pytest.raises((TypeError, ValueError), match="degree.*should be.*int|Invalid value.*degree"):
        Polyfit2DModel(degree=bad_type)


@pytest.mark.parametrize("bad_type", [1.5, "2", float("nan"), np.nan, None, [1], (2,), {"a": 1}])
def test_polyfit2d_deriv1_non_int_type(bad_type) -> None:
    """
    Test that Polyfit2DModel raises error for non-integer deriv1 types.

    Parameters
    ----------
    bad_type : Union[float, str, None, List[int], Tuple[int], dict]
        Invalid deriv1 type.
    """
    with pytest.raises((TypeError, ValueError), match="deriv1.*should be.*int|Invalid value.*deriv1"):
        Polyfit2DModel(deriv1=bad_type)


@pytest.mark.parametrize("bad_type", [1.5, "2", float("nan"), np.nan, None, [1], (2,), {"a": 1}])
def test_polyfit2d_deriv2_non_int_type(bad_type) -> None:
    """
    Test that Polyfit2DModel raises error for non-integer deriv2 types.

    Parameters
    ----------
    bad_type : Union[float, str, None, List[int], Tuple[int], dict]
        Invalid deriv2 type.
    """
    with pytest.raises((TypeError, ValueError), match="deriv2.*should be.*int|Invalid value.*deriv2"):
        Polyfit2DModel(deriv2=bad_type)


def test_polyfit2d_model_predict_wrong_features() -> None:
    """Test that predict method raises error for incorrect number of features."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)

    # Test with two 2D inputs
    X_pred_2d = np.array([[0.1, 0.2], [0.3, 0.4]])
    with pytest.raises(ValueError, match="X1 and X2 must be 1D arrays"):
        model.predict(X_pred_2d, X_pred_2d)

    # Test with 3D input
    X_pred_3d = np.column_stack([X, np.ones(X.shape[0])])
    with pytest.raises(ValueError, match="X1 and X2 must be 1D arrays,"):
        model.predict(X_pred_3d, X_pred_3d)


def test_polyfit2d_model_predict_without_fit() -> None:
    """Test that predict method raises error when called before fitting."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    with pytest.raises(ValueError, match="This .* instance is not fitted yet"):
        model.predict(x_new1, x_new2)


def test_polyfit2d_model_get_fitted_grids() -> None:
    """Test that get_fitted_grids method returns correct fitted values."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)

    # Test if fitted grids are returned correctly
    grid1, grid2, fitted_values = model.get_fitted_grids()
    assert grid1.shape == x_new1.shape
    assert grid2.shape == x_new2.shape
    assert fitted_values.shape == (len(x_new1), len(x_new2))
    assert np.all(np.isfinite(fitted_values)), "Fitted values contain NaN or Inf"


def test_polyfit2d_model_x_new1_out_of_range() -> None:
    """Test that Polyfit2DModel raises error for x_new1 outside input range."""
    X, y, w, _, x_new2 = make_test_inputs_2d()

    # Test with observation grid outside input range for first dimension
    x_new1_bad = np.array([0.0, 0.6])  # Outside [0.1, 0.5]
    model = Polyfit2DModel(obs_grid1=x_new1_bad, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="obs_grid1 must be within the range of input X\\[:, 0\\]"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new2_out_of_range() -> None:
    """Test that Polyfit2DModel raises error for x_new2 outside input range."""
    X, y, w, x_new1, _ = make_test_inputs_2d()

    # Test with observation grid outside input range for second dimension
    x_new2_bad = np.array([0.0, 0.6])  # Outside [0.1, 0.5]
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2_bad)
    with pytest.raises(ValueError, match="obs_grid2 must be within the range of input X\\[:, 1\\]"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new1_wrong_shape() -> None:
    """Test that Polyfit2DModel raises error for incorrect x_new1 shape."""
    X, y, w, _, x_new2 = make_test_inputs_2d()

    # Test with 2D observation grid for first dimension
    x_new1_2d = np.array([[0.1, 0.2], [0.3, 0.4]])
    model = Polyfit2DModel(obs_grid1=x_new1_2d, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="obs_grid1 must be a 1D array"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new2_wrong_shape() -> None:
    """Test that Polyfit2DModel raises error for incorrect x_new2 shape."""
    X, y, w, x_new1, _ = make_test_inputs_2d()

    # Test with 2D observation grid for second dimension
    x_new2_2d = np.array([[0.1, 0.2], [0.3, 0.4]])
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2_2d)
    with pytest.raises(ValueError, match="obs_grid2 must be a 1D array"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new1_too_few_points() -> None:
    """Test that Polyfit2DModel raises error for x_new1 with too few points."""
    X, y, w, _, x_new2 = make_test_inputs_2d()

    # Test with observation grid with too few points for first dimension
    x_new1_short = np.array([0.3])  # Only 1 point
    model = Polyfit2DModel(obs_grid1=x_new1_short, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="obs_grid1 must have at least 2 points"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new2_too_few_points() -> None:
    """Test that Polyfit2DModel raises error for x_new2 with too few points."""
    X, y, w, x_new1, _ = make_test_inputs_2d()

    # Test with observation grid with too few points for second dimension
    x_new2_short = np.array([0.3])  # Only 1 point
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2_short)
    with pytest.raises(ValueError, match="obs_grid2 must have at least 2 points"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new1_with_nan() -> None:
    """Test that Polyfit2DModel raises error for x_new1 containing NaN values."""
    X, y, w, _, x_new2 = make_test_inputs_2d()

    # Test with observation grid containing NaN for first dimension
    x_new1_nan = np.array([0.1, np.nan, 0.3])
    model = Polyfit2DModel(obs_grid1=x_new1_nan, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="Input contains NaN"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_model_x_new2_with_nan() -> None:
    """Test that Polyfit2DModel raises error for x_new2 containing NaN values."""
    X, y, w, x_new1, _ = make_test_inputs_2d()

    # Test with observation grid containing NaN for second dimension
    x_new2_nan = np.array([0.1, np.nan, 0.3])
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2_nan)
    with pytest.raises(ValueError, match="Input contains NaN"):
        model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)


def test_polyfit2d_wrong_interp_kind() -> None:
    """Test that Polyfit2DModel raises error for invalid interpolation kind."""
    with pytest.raises(ValueError, match="interp_kind must be one of"):
        Polyfit2DModel(interp_kind="invalid")


def test_polyfit2d_wrong_bandwidth_selection_method() -> None:
    """Test that Polyfit2DModel raises error for invalid bandwidth selection method."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="bandwidth_selection_method must be one of"):
        model.fit(X, y, sample_weight=w, bandwidth_selection_method="invalid")


def test_polyfit2d_num_bw_candidates() -> None:
    """Test that Polyfit2DModel validates number of bandwidth candidates correctly."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)

    # Test non-integer num_bw_candidates
    with pytest.raises(TypeError, match="Number of bandwidth candidates, num_bw_candidates, should be an integer"):
        model.fit(X, y, sample_weight=w, num_bw_candidates=1.5)

    # Test too few candidates
    with pytest.raises(ValueError, match="Number of bandwidth candidates, num_bw_candidates, should be at least 2"):
        model.fit(X, y, sample_weight=w, num_bw_candidates=1)


def test_polyfit2d_cv_folds() -> None:
    """Test that Polyfit2DModel validates cross-validation folds correctly."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    with pytest.raises(ValueError, match="Number of cross-validation folds, cv_folds, should be at least 2"):
        model.fit(X, y, sample_weight=w, bandwidth_selection_method="cv", cv_folds=1)


def test_polyfit2d_predict_with_direct_call() -> None:
    """Test Polyfit2DModel prediction with direct polyfit2d call."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2)
    model.fit(X, y, sample_weight=w, bandwidth1=0.1, bandwidth2=0.1)

    # Test prediction with direct call (use_model_interp=False)
    y_pred_direct = model.predict(x_new1, x_new2, use_model_interp=False)
    assert y_pred_direct.shape == (len(x_new1), len(x_new2))
    assert np.all(np.isfinite(y_pred_direct)), "Direct prediction contains NaN or Inf values"

    # Test prediction with interpolation (use_model_interp=True)
    y_pred_interp = model.predict(x_new1, x_new2, use_model_interp=True)
    assert y_pred_interp.shape == (len(x_new1), len(x_new2))
    assert np.all(np.isfinite(y_pred_interp)), "Interpolated prediction contains NaN or Inf values"


def test_polyfit2d_custom_bw_candidates() -> None:
    """Test Polyfit2DModel with custom bandwidth candidates."""
    X, y, w, x_new1, x_new2 = make_test_inputs_2d()
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2, random_seed=100)

    # Test with 2D custom bandwidth candidates
    custom_bw = np.array([[0.1, 0.1], [0.2, 0.2], [0.3, 0.3]])
    model.fit(X, y, sample_weight=w, custom_bw_candidates=custom_bw)

    # Test invalid shape for custom_bw_candidates
    custom_bw_1d = np.array([0.1, 0.2, 0.3])
    with pytest.raises(ValueError, match="custom_bw_candidates must have exactly 2 features"):
        model.fit(X, y, sample_weight=w, custom_bw_candidates=custom_bw_1d.reshape(-1, 1))


def test_polyfit2d_insufficient_data_for_degree() -> None:
    """Test that Polyfit2DModel raises error when there's insufficient data for the polynomial degree."""
    # Create minimal dataset
    X = np.array([[0.1, 0.1], [0.2, 0.2]])
    y = np.array([0.1, 0.2])
    w = np.array([1.0, 1.0])
    x_new1 = np.array([0.1, 0.2])
    x_new2 = np.array([0.1, 0.2])

    # Try to fit with high degree that requires more data points
    model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2, degree=5)

    # This should raise an error during bandwidth selection or fitting
    with pytest.raises(ValueError, match="Not enough unique support points"):
        model.fit(X, y, sample_weight=w)


# @pytest.mark.parametrize("method", ["cv", "gcv"])
# def test_polyfit2d_bandwidth_selection(method: str) -> None:
#     """
#     Test Polyfit2DModel with different bandwidth selection methods.

#     Parameters
#     ----------
#     method : str
#         Bandwidth selection method to test.
#     """
#     X, y, w, x_new1, x_new2 = make_test_inputs_2d()
#     model = Polyfit2DModel(obs_grid1=x_new1, obs_grid2=x_new2, random_seed=100)

#     # Note: Since 2D bandwidth selection is not fully implemented yet,
#     # we expect these to work with the placeholder implementation
#     try:
#         model.fit(X, y, sample_weight=w, bandwidth_selection_method=method)
#         assert hasattr(model, "bandwidth1_"), "bandwidth1_ should be set after fitting"
#         assert hasattr(model, "bandwidth2_"), "bandwidth2_ should be set after fitting"
#     except NotImplementedError:
#         pytest.skip(f"2D {method} bandwidth selection not yet implemented")
